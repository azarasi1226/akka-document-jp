# アクターシステム
アクターは状態と振る舞いをカプセル化されたオブジェクトのことであり、アクター同士でメッセージを相互に送り合い処理を完遂していきます。
そのアクターの集合体はアクターシステムと呼ばれています。
Akkaでのアクターシステムは設定(application.conf)やログなどの共通機能を管理する単位と位置づけられており、この単位が1JVM内での最大単位となっています。

`ActorSystem.create()`メソッドによって一番最初のアクターを生成すると同時にアクターシステムも起動します。

> ActorSystemは1~個のスレッドを使って処理をする非常に巨大な単位ですので、一つのコンピューター・コンテナ・JVMに一つの単位で設置することが推奨されます。

<br>

## アクターシステムは階層構造
アクターシステムはアクターの階層(ファイルシステムのディレクトリ的な)を形成しており、親アクターが子アクターを生成することにより階層を作成しています。
この階層構造の真骨頂はタスクが分割され、一つの小さなアクターを高凝集にできることです。
タスク自体が明確に構造化されることにより、そのアクターはどのようなメッセージを処理するべきなのか、通常どういった動きをするべきなのか、失敗時はどう処理するべきなのかと言ったビジネスロジックを推論することができるようになります。これはある意味究極のカプセル化と言えます。

このようなシステムを設計する際に難しいのはタスクの構成をどの単位で区切って行くのかということです。
最適解は無いですが、参考になりそうなガイドラインがいくつか存在します。

* もし一つのアクターが複数の責務を保つ場合、それぞれの責務に合わせて別の子を作成しロジックと状態をシンプルにする。
* あるアクターがその責務を遂行するために他のアクターに依存している場合、そのアクターは他のアクターの生存状態を監視し、適切に子アクターを管理する(スーパーバイザ戦略)

<br>

## アクターにおけるベストプラクティス
アクターシステムを安全に構成するためにアクター単体で注意しなくてはいけないことがいくつかあります。

1. アクターは他のアクターのリソースを専有しないようにします。止む終えない場合を除き、ファイルやネットワークソケットなど外部のリソースをブロック(そのスレッドで占領したままにすること)してはいけません。
2. アクター間ではミュータブルなオブジェクトを受け渡ししてはいけません。これは並行処理時などの他のスレッドからメッセージが書き換えられてしまう可能性があるからです。せっかくマルチスレッドプログラムが簡単になるようにAkkaさんが頑張ってくれてるのに台無しです。
3. アクターはメッセージを受け入れることで、内部で定義された振る舞いを経て状態を変更していくのが基本的な動きです。メッセージに挙動(Scalaのクロージャとか、コールバック関数とか)を含めては行けません。
4. アクターシステムのトップレベルのアクターにはロジックを含めてはいけません。親アクターは子アクターの管理だけに集中し、ビジネスロジックはすべて子アクターで処理するのが理想です。親はスーパーバイザ戦略により子を見守るだけの存在になりましょう

<br>

## アクターシステムの終了
ユーザーガーディアンアクタを停止するか、ActorSystemの`terminate()`メソッドを呼び出すことによって実行中のアクタがすべて停止します。