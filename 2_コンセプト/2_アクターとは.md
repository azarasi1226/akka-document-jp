# アクターとは
以前のアクターシステムの説明で、アクターは階層を形成しアプリケーションを構成する最小の単位であることを説明しました。今回はその参照単位であるアクターに関して詳しく解説して行こうと思います。

アクターは以下の３つの基本原則だけで成り立っています。

* 知っている送信先のアクタにN個のメッセージを送信する
* N個の新しいアクターを作成する
* メッセージが送られてきた際の振る舞いを定義する

アクターは`State(状態)`・`Behavir(振る舞い)`・`Mailbox`・`子アクター`・ `スーパーバイザ`という要素で構成されています。
ここで注意していただきたいのが、`一度アクターを作ったら参照されなくなったからといって自動的に破棄されない`ということです。
(ガベージコレクションされない)アクターの停止・破棄の管理は開発者のお仕事なのです。

<br>

## アクターの参照(ActorRef)
`context.spanw()`等でアクターは生み出しますが、その戻り値はすべて`ActoreRef`となっています。つまりアクターの参照を表すオブジェクトです。
アクターモデルの恩恵を受けるためには、アクターの実態を外部から完全に隠蔽する必要があるからです。
(アクターにはメッセージ経由でしかやり取りさせないメッセージ駆動なのに、直接オブジェクト操作されたら台無しだし、位置透過性が効かなくなるから)

この参照を使ってやり取りする仕組みのお陰でアクターは実体の位置に関係なくメッセージを送信することができます。
ローカルでもリモートでもクラスターでもまったく同じやり方でメッセージのやり取りを行うことができます。

またアクター参照はジェネリクスによって型指定され、指定されたタイプのメッセージしか送信できません。

<br>

## 状態
アクターに含まれている状態は他のアクターから完全に保護されていなければいけません。
ここで朗報です、Akkaでは概念的にそれぞれ独自の軽量スレッドを上でアクターを動かしており、それぞれのアクターは外部からの変更に保護されています。
また、一つのアクターはメッセージボックスから一つずつしか処理できない制約のお陰で、並列処理特有のリソースロックなどが不要になります。

ちなみにアクターはメモリ上に保存されているデータのため、アクターが失敗し親のスーパーバイザによって再起動されるときには状態がリセットされます。`AkkaPersistence`という機能を使えばイベントソーシングの原理で状態が保持できます。

<br>

## 振る舞い(Behavior)
アクターにメッセージが送信されるたびに、アクターは予め登録していた振る舞いと照合しメッセージを適切に処理します。
この予め登録していた処理をBehaviorと呼びます。

<br>

## MailBox
アクターの目的は送られてくるメッセージの処理でした。これらのメッセージは一度メールボックスと呼ばれるキューに送られ、アクターはそのメールボックスからメッセージを一つずつ取り出すことで振る舞いを実行します。
各アクターではこのメールボックスを一つだけ持っており、取り出し方法はデフォルトでFIFO(先入れ先出し)です。
この取り出し方法はカスタマイズすることが可能であり、メッセージの優先順番順などにすることが可能です。

<br>

## 子アクター
すべてのアクター子を持つことができ潜在的に親です。
サブタスクを委譲するために子を作成すると、自動的にその子を監督する対場になります。
子の生成と終了はバックグラウンドで非同期的に行われるため親をブロックすることはありません。

<br>

## スーバーバイザ戦略
アクターの最後の構成要素は、予期せぬ例外つまりエラーを処理するための機構です。
子が発したエラーを親は監督し、再起動するか・停止するか・状態をそのまま復元するかなど選択することが可能となります。