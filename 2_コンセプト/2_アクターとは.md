# アクターとは
以前のアクターシステムの説明で、アクターが階層を形成しアプリケーションを構成する最小の単位であることを説明しました。今回はその参照単位であるアクターに関して詳しく解説して行こうと思います。

アクターは以下の３つの基本原則だけで成り立っています。

* 知っている送信先のアクタにN個のメッセージを送信する
* N個の新しいアクターを作成する
* メッセージが送られてきた際の振る舞いを定義する

アクタはー`State(状態)`・`Behavir(振る舞い)`・`Mailbox`・`子アクター`・ `スーパーバイザ`をすべて含んだ入れ物のようなものです。
ここで注意していただきたいのが、`一度アクターを作ったら参照されなくなったからといって自動的に破棄されない`ことです。
(ガベージコレクションされない)アクターの停止・破棄の管理は開発者のお仕事なのです。

<br>

## アクターの参照(ActorRef)
`context.spanw()`等でアクターは生み出しますが、その戻り地は`ActoreRef`となっています。つまりアクターの参照を表すオブジェクトです。
アクターモデルの恩恵を受けるためには、アクターの実態を外部から完全に隠蔽する必要があるのです。<br>
(アクターにはメッセージ経由でしかやり取りさせないメッセージ駆動なのに、直接オブジェクト操作されたら全て台無しだし、位置透過性が効かなくなるから)

この参照を使ってやり取りする仕組みのお陰でアクターは実体の位置に関係なくメッセージを送信することができます。
ローカルでもリモートでもクラスターでもまったく同じやり取りでメッセージのやり取りを行うことができます。

またアクター参照はジェネリクスによって型指定され、指定されたタイプのメッセージしか送信できません。

<br>

## 状態
アクターに含まれている状態は他のアクターから完全に保護されていなければいけません。
ここで朗報です、Akkaは概念的にそれぞれ独自の軽量スレッドを持っており他のアクターから自分のアクターを完全に隠蔽しています。
つまり、メッセージボックスから一つずつ処理し同期する代わりに、並列処理をまったく気にせずにアクターをコーディングできます。

ちなみにアクターはメモリ上に保存されているデータのため、アクターが失敗し親のスーパーバイザによって再起動されるときには状態がリセットされます。`AkkaPersistence`という機能を使えばイベントソーシングの原理で状態が保持されるので復活後も元の状態に戻っています。

<br>

## 振る舞い(Behavior)
アクターにメッセージが送信されるたびに、アクターは予め登録していた振る舞いと照合しメッセージを適切に処理します。
この予め登録していた処理をBehaviorと呼びます。

<br>

## MailBox
アクターの目的は送られてくるメッセージの処理でした。これらのメッセージは一度メールボックスと呼ばれるキューに送られ、アクターはそのメールボックスからメッセージを一つずつ取り出すことで振る舞いを実行します。
各アクターではこのメールボックスを一つだけ持っており、取り出し方法はデフォルトではFIFO(先入れ先出し)法です。
この取り出し方法はカスタマイズすることが可能であり、メッセージの優先順番順などにすることが可能です。

<br>

## 子アクター
すべてのアクター子を持つことができ潜在的に親です。
サブタスクを委譲するために子を作成すると、自動的にその子を監督する対場になります。
子の生成と終了はバックグラウンドで非同期的に行われるため親をブロックすることはありません。

<br>

## スーバーバイザ戦略
アクターの最後の構成要素は、予期せぬ例外つまり失敗を処理するための機構です。
子が発したエラーを親は監督し、再起動するか・停止するか・状態をそのまま復元するかなど選択することが可能になります。