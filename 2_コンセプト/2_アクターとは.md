# アクターとは
以前のアクターシステムの説明で、アクターが階層を形成しアプリケーションを構成する最小の単位であることを説明しました。今回はその参照単位であるアクターに関して詳しく解説して行こうと思います。

アクターは以下の３つの基本原則だけで成り立っています。

* 知っている送信先のアクタにN個のメッセージを送信する
* N個の新しいアクターを作成する
* メッセージが送られてきた際の振る舞いを定義する

アクタはーState(状態), Behavir(振る舞い), Mailbox, 子アクター, スーパーバイザをすべて含んだ入れ物のようなものです。
ここで注意していただきたいのが、`一度アクターを作ったら参照されなくなったからといって自動的に破棄されない`ことです。
(ガベージコレクションされない)アクターの停止・破棄の管理は開発者のお仕事なのです。

<br>

## アクターの参照(ActorRef)
`context.spanw()`等でアクターは生み出しますが、その戻り地は`ActoreRef`となっています。つまりアクターの参照を表すオブジェクトです。
アクターモデルの恩恵を受けるためには、アクターの実態を外部から完全に隠蔽する必要があるのです。<br>
(アクターにはメッセージ経由でしかやり取りさせないメッセージ駆動なのに、直接オブジェクト操作されたら全て台無しだし、位置透過性が効かなくなるから)

この参照を使ってやり取りする仕組みのお陰でアクターは実体の位置に関係なくメッセージを送信することができます。
ローカルでもリモートでもクラスターでもまったく同じやり取りでメッセージのやり取りを行うことができます。

またアクター参照はジェネリクスによって型指定され、指定されたタイプのメッセージしか送信できません。

<br>

## 状態
アクターに含まれている状態は他のアクターから完全に保護されていなければいけません。
ここで朗報です、Akkaは概念的にそれぞれ独自の軽量スレッドを持っており他のアクターから自分のアクターを完全に隠蔽しています。
つまり、メッセージボックスから一つずつ処理し同期する代わりに、並列処理をまったく気にせずにアクターをコーディングできます。

ちなみにアクターはメモリ上に保存されているデータのため、アクターが失敗し親のスーパーバイザによって再起動されるときには状態がリセットされます。`AkkaPersistence`という機能を使えばイベントソーシングの原理で状態が保持されるので復活後も元の状態に戻っています。

<br>

## 振る舞い(Behavior)
アクターにメッセージが送信されるたびに、アクターは予め登録していた振る舞いと照合しメッセージを適切に処理します。
この予め登録していた処理をBehaviorと呼びます。

<br>

## MailBox
アクターの目的はメッセージの処理であり、これらのメッセージは他のアクターから（またはアクター・システムの外部から）アクターに送信されました。送信者と受信者をつなぐ部品はアクターのメールボックスです。各アクターは、すべての送信者がメッセージをエンキューするメールボックスを正確に1つ持っています。各アクターは、すべての送信者がメッセージを列挙するメールボックスを1つだけ持ちます。列挙は、送信操作の時間順序で行われ、これは、スレッド間でアクターを分散する際の見かけ上のランダム性により、異なるアクターから送信されたメッセージが実行時に定められた順序を持っていないかもしれないことを意味しています。一方、同じアクターから同じターゲットに複数のメッセージを送信すると、同じ順序でエンキューされます。

選択できるメールボックスの実装は様々で、デフォルトはFIFOです：アクターによって処理されるメッセージの順番は、それらがエンキューされた順番と一致します。これは通常良いデフォルトですが、アプリケーションはあるメッセージに他のメッセージより優先順位をつける必要がある場合があります。この場合、プライオリティ・メールボックスは常に最後ではなく、メッセージの優先順位で指定された位置で待ち行列に入ることになります。このようなキューを使用している間、処理されるメッセージの順序は当然キューのアルゴリズムによって定義され、一般的には FIFO ではありません。

Akka が他のアクターモデル実装と異なる重要な点は、現在の動作は常に次のキューに入れられたメッセージを処理しなければならず、次にマッチするメッセージのためにメールボックスをスキャンすることはない、という点です。メッセージの処理に失敗した場合は、この挙動がオーバーライドされない限り、通常失敗として扱われます。



