# アクターの監督(スーパービジョン)
子アクターで発生したエラーをうまく処理する仕組みをスーパーバイザ戦略と以前説明しました。
重要な概念なのでこの章では更に詳しく解説していこうと思います。

データの検証や予測される例外等はビジネスロジックの重要な部分なので予めアクターのメッセージ処理ロジックに追加します。　
(ID無いのにユーザーの問い合わせをした、とか)
しかし予期しない障害が発生する場合が稀にあります。例えば、ネットワークリソースが追加できない、ディスクの書き込みが失敗する、開発者が予期してないアプリケーションロジックのバグなどです。
これらはアクターのメッセージ処理ロジックと混ざり合うべきではなくスーパバイザ戦略を利用し、ひとつ上の階層(親に)判断してもらうべきです。

監督する性質に応じてAkkaは３つの戦略を提供します。

1. 蓄積された内部の状態を維持しながらアクターを再開する。
2. アクターを再起動し、蓄積された内部の状態はクリアされる。
3. アクターを完全に停止する(初期戦略)

アクターは階層構造によって構築されていると以前説明しましたが、これは障害を上方に伝播し親に処理してもらう仕組みと理にかなっています。
例えですが、直近の親ではなく２子上の階層のアクター(おじいちゃんアクター？w)に障害時の処理を委譲することができるのです。
これは通常の例外のtry-catchの仕組みに似ているのでなんとなく理解できると思います。
後述する`アクターの監視通知の仕組み`を組み合わせて実現できるのですが`context.watch(childRef)`を使用して子を監視すると子が停止した際、親も一緒に`DeathPactException`を吐き停止しようとするのでこれを連続して書くとエラーバブルアウトの仕組みを構築できます。

<br>
<br>

# アクターの監視(モニタリング)
> Akkaのアクターライフサイクル監視は停止時しか監視できないので別名`DeathWatch`と呼ばれています。

上記では主に階層構造(親子関係)での監督の話をしてきましたが、各アクターは階層を無視した全く別のアクターを監視することができます。
ちなみに監視できる唯一の状態変化は`停止`だけで再起動は停止も一瞬していますがスパーバイザの包まれてしまうため見えません。

監視すると小アクターが停止した際に`Terminated`メッセージを受信します。このメッセージは適切にレシーバーで処理されない場合親アクターは`DeathPathException`をスローするので注意が必要です。

> 先程の監督の説明でエラーは監視の仕組みと君合わせるとバブルアウトできると言いましたがこれのことです。

`AcotrContext.watch(targetRef)`で監視を開始し、`ActorContext.unwatch(targetRef)`で監視を終了することができます。

<br>
<br>

# 例外とかでアクターが停止するとどうなるの？

## メッセージは？
メッセージの処理中にアクターが停止した場合は再起動したとしてもメッセージは失われます(メールボックスにも入っていない)。
したがって、メッセージの処理中に例外が発生した場合は親アクターでもう一回メッセージを送信するような処理を自分で書かなければなりません。

また、無限リトライが発生する可能性があるので試行回数に制限を設けないと無いと積む場合があります。

<br>

## メールボックスの中身は？
メールボックスはアクターと隔離されているので何も起こりません。
アクターが再起動すると同じメールボックスが存在し、メールボックス内のすべてのメッセージも再度閲覧することができます。

<br>

## アクターはどうなるの？
アクター内のコードで例外をスローするとそのアクターは一時中断され監督もしくは監視プロセスが開始されます。
スーパーバイザの決定に応じアクターは再起動・停止・再開します。