## 依存関係
とりあえず今回の解説で使う依存関係です。Gladleに追加してください。
    
```gradle
def versions = [
  ScalaBinary: "2.13"
]
dependencies {
  implementation platform("com.typesafe.akka:akka-bom_${versions.ScalaBinary}:2.6.19")

  implementation "com.typesafe.akka:akka-actor-typed_${versions.ScalaBinary}"
}
```
<br>
<br>

## イントロダクション
Akkaを使用すると、アクターシステムのインフラストラクチャを作成したり、基本的な動作を制御するために必要な低レベルのコードを書いたりする手間が省けます。  
このことを理解するために、どうやってアクターを作成するのか、またAkkaが内部で作成・管理するアクターとの関係、アクターのライフサイクル、及び障害対策について見ていきましょう！

<br>
<br>

## Akkaアクターの階層
Akkaのアクターには階層構造が存在し、制作するアクターは常に何らかの親アクターが存在します。  
最初のアクターは ```ActerSystem``` によって作成し、アクターを追加で作成するには、```ActorContext.spawn()``` を呼び出します。
親アクターの中で新しく作成されたアクターはそのアクターの子アクターとなります。  
じゃぁ... ```ActerSystem``` によって最初に作成されたActorは誰が親なんでしょうか？

下図に示すように、すべてのアクタは共通の親である **ガーディアン(守護者・後見人・親)** を持っており、これは ```ActorSystem``` の起動時に定義され作成されます。クイックスタートガイドで説明したように、アクタの作成は有効な URL である参照を返します。
例えば ```context.spawn(someBehavior, "someActor")``` でユーザーガーディアンから someActor という名前のアクターを作成すると、その参照には /user/someActor というパスになります。

![](https://doc.akka.io/docs/akka/current/typed/guide/diagrams/actor_top_tree.png)

実は、最初のアクターが起動する前にAkka はすでにシステム内に 3 つのアクターを作成しています。  
これらの組み込みアクターの名前には、ガーディアンと呼ばれ、特殊なアクターになっており以下の３つが存在します。

* ```/``` いわゆるルートガーディアンです。これはシステム内のすべてのアクターの親であり、システム自体が終了したときに最後に停止します。  
(後で説明しますが、Actorは停止する際に子から再帰的に停止していきます)

* ```/system``` システムガーディアン。Akka または Akka の上に構築された他のライブラリは、system ネームスペースにアクターを作成することができます。

* ```/user``` ユーザーガーディアンです。これは、アプリケーション内の他のすべてのアクターを起動するために提供するトップレベルのアクターです。

アクター階層を実際に見る最も簡単な方法は、```ActorRef``` インスタンスを```toString()```で出力することです。  
今回のサンプルではアクターを作成し、その参照を表示しこのアクターの子を作成し、その子の参照を表示します。

```kotlin
import akka.actor.typed.ActorSystem
import akka.actor.typed.Behavior
import akka.actor.typed.javadsl.AbstractBehavior
import akka.actor.typed.javadsl.ActorContext
import akka.actor.typed.javadsl.Behaviors
import akka.actor.typed.javadsl.Receive

/**
 * 最後に呼ばれるアクター
 */
class Second private constructor(
    context: ActorContext<String>
): AbstractBehavior<String>(context) {
    override fun createReceive(): Receive<String> {
        return newReceiveBuilder()
            .onMessageEquals("apply2") { apply2() }
            .build()
    }

    private fun apply2(): Behavior<String?> {
        val secondRef = context.spawn(Behaviors.empty<String>(), "second-actor")

        println("Second: $secondRef")

        return this
    }

    companion object {
        fun create(): Behavior<String> {
            return Behaviors.setup { context: ActorContext<String> -> Second(context) }
        }
    }
}


/**
 * 最初に呼ばれるアクター
 */
class First private constructor(
    context: ActorContext<String>
): AbstractBehavior<String>(context) {
    override fun createReceive(): Receive<String> {
        return newReceiveBuilder()
            .onMessageEquals("apply1") { apply1() }
            .build()
    }

    private fun apply1(): Behavior<String> {
        val firstRef = context.spawn(Second.create(), "first-actor")

        println("First: $firstRef")
        firstRef.tell("apply2")

        return this
    }

    companion object {
        fun create(): Behavior<String> {
            return Behaviors.setup { context: ActorContext<String> -> First(context) }
        }
    }
}

/**
 * エントリーポイント
 */
fun main() {
    val first = ActorSystem.create(First.create(), "first")
    first.tell("apply1")
}
```

メッセージが最初のアクタに仕事を依頼する方法に注目してください。  
```firstRef.tell("apply2")``` というように、アクターの中で作成した参照を使って子アクターにメッセージを送信しています。
このコードが実行されると、以下のように出力されるはずです。

```
First: Actor[akka://testSystem/user/first-actor#-173533558]
Second: Actor[akka://testSystem/user/first-actor/second-actor#-1659852452]
```

アクター階層がどのようなものかを理解したところで、不思議に思うかもしれません。
なぜこのような階層構造が必要なんだろうか?と

階層構造の重要な役割は、アクターのライフサイクルを安全に管理することです。
次はアクターのライフサイクルがどんなものなのか見ていきましょう。

<br>
<br>

## アクーターのライフサイクル
アクターは、作成された後にユーザーの要求により停止される。またアクターが停止されるたびに、その子もすべて再帰的に停止されます。  
この再帰的な停止により、リソースのクリーンアップなどが非常に簡単になり、オープンソケットやファイルによるリソースリークを回避することができます。
実際低レベルのマルチスレッドコードを扱う際にこれを自前で実装するのはとても大変です。

アクターを停止するには、アクターの内部で ```Behaviors.stopped()``` を返してそれ自体を停止させるのが推奨パターンです。
通常は、ユーザーが定義の停止メッセージへの応答として、またはアクタがその仕事を終えたときに停止します。
子アクタの停止は、親から ```context.stop(childRef)``` を呼び出すことでも可能ですが、あくまでも親が保持している子アクターの停止しかできません。

Akka アクターは、いくつかのライフサイクルシグナルを公開します。
たとえば、```PostStop``` はアクタが停止した直後に送信されるシグナルです。
これが呼ばれたあとはアッカアクターは停止しており、メッセージが呼ばれることはありません。

ライフサイクルシグナル ```PostStop``` を使って、アクターを停止させたときの挙動を観察する簡単な実験をしてみましょう。
まず、以下の2つのアクタークラスを作成して起動してみてください。

```kotlin
import akka.actor.typed.ActorSystem
import akka.actor.typed.Behavior
import akka.actor.typed.PostStop
import akka.actor.typed.javadsl.AbstractBehavior
import akka.actor.typed.javadsl.ActorContext
import akka.actor.typed.javadsl.Behaviors
import akka.actor.typed.javadsl.Receive

/**
 * 最初に停止されるアクター
 */
class StartStopActor2 private constructor(
    context: ActorContext<String>
): AbstractBehavior<String>(context) {
    init {
        println("Second Start")
    }

    override fun createReceive(): Receive<String> {
        return newReceiveBuilder()
            // PostStopシグナルが送信されたらonPostStop()実行
            .onSignal(PostStop::class.java) { _: PostStop? -> onPostStop() }
            .build()
    }

    private fun onPostStop(): Behavior<String> {
        println("Second Stop!")

        return this
    }

    companion object {
        fun create(): Behavior<String> {
            return Behaviors.setup {
                    context: ActorContext<String> -> StartStopActor2(context)
            }
        }
    }
}

/**
 * ２番目に停止するアクター
 */
class StartStopActor1 private constructor(
    context: ActorContext<String>
): AbstractBehavior<String>(context) {
    init {
        println("First Start")

        //どこの参照にも入れないけどとりあえずアクター作成
        //これだけで小アクターとして登録されるよ！
        context.spawn(StartStopActor2.create(), "second")
    }

    override fun createReceive(): Receive<String> {
        return newReceiveBuilder()
            // stopメッセージが来たらアクターをBehaveirs.stopped()を返して停止させる
            .onMessageEquals("stop") { Behaviors.stopped() }
            .onSignal(PostStop::class.java) { _: PostStop? -> onPostStop() }
            .build()
    }


    private fun onPostStop(): Behavior<String> {
        println("First Stop!")

        return this
    }

    companion object {
        fun create(): Behavior<String> {
            return Behaviors.setup { context: ActorContext<String> -> StartStopActor1(context)
            }
        }
    }
}

/**
 * エントリーポイント
 */
fun main(){
    val first = ActorSystem.create(StartStopActor1.create(), "first")
    first.tell("stop")
}
```

出力はこんな感じになるはずです。
作成と逆の順番でストップしていくのがわかるでしょう。
```
first started
second started
second stopped
first stopped
```

繰り返しになりますが、Akka アクターは親が停止されるとまず子を再帰的に停止していきま、この順番は絶対です。  
今回の例では親のPostStopシグナルが処理される前に、子のPostStopシグナルがすべて処理されます。

<br>
<br>

## エラーハンドリング
親と子はそのライフサイクルを通じて接続されています。アクターが失敗する（例外を投げる、あるいは未処理の例外が ```Receive``` からバブルアウトする）と、失敗情報が監督システムに伝わり、監督システムはアクターが引き起こした例外をどのように処理するかを決定します。  
監視システムは、通常、親アクターが子アクターを生成する際に定義されます。このように、親アクターは子アクターのスーパーバイザーとして機能します。  
デフォルトのスーパーバイザーは、子アクターを停止することです。戦略を定義しない場合、すべての失敗が停止になります。


簡単な実験で、再起動を観察してみましょう。先程と同じように、以下のクラスをプロジェクトに追加してください

```kotlin
import akka.actor.typed.*
import akka.actor.typed.javadsl.AbstractBehavior
import akka.actor.typed.javadsl.ActorContext
import akka.actor.typed.javadsl.Behaviors
import akka.actor.typed.javadsl.Receive

/**
 * 監督される側
 */
class SupervisedActor private constructor(
    context: ActorContext<String>
): AbstractBehavior<String>(context) {
    init {
        println("子：起動するよ")
    }

    override fun createReceive(): Receive<String> {
        return newReceiveBuilder()
            .onMessageEquals("fail") { fail() }
            .onSignal(PreRestart::class.java) { _ -> preRestart() }
            .onSignal(PostStop::class.java) { _ -> postStop() }
            .build()
    }

    private fun fail(): Behavior<String?> {
        println("子：今から例外で異状停止を再現するよ！")

        throw RuntimeException()
    }

    private fun preRestart(): Behavior<String> {
        println("子：リスタート")

        return this
    }

    private fun postStop(): Behavior<String> {
        println("子：停止")

        return this
    }

    companion object {
        fun create(): Behavior<String> {
            return Behaviors.setup { context: ActorContext<String> -> SupervisedActor(context) }
        }
    }
}

/**
 * 監督する側
 */
class SupervisingActor private constructor(
    context: ActorContext<String>
): AbstractBehavior<String>(context) {
    private val child: ActorRef<String>

    init {
        child = context.spawn(
            // 監視してActorを作成する。ちなみにこれは子が落ちたらその子を再起動させるという意味
            Behaviors.supervise(SupervisedActor.create())
                .onFailure(SupervisorStrategy.restart()),
            "supervised-actor"
        )
    }

    override fun createReceive(): Receive<String> {
        return newReceiveBuilder()
            .onMessageEquals("failChild") { onFailChild() }
            .onMessageEquals("stop"){ Behaviors.stopped() }
            .onSignal(PostStop::class.java) { _ -> postStop() }
            .build()
    }

    private fun onFailChild(): Behavior<String> {
        child.tell("fail")

        return this
    }

    private fun postStop(): Behavior<String> {
        println("親:停止")

        return this
    }

    companion object {
        fun create(): Behavior<String> {
            return Behaviors.setup { context: ActorContext<String> -> SupervisingActor(context) }
        }
    }
}

/**
 * エントリーポイント
 */
fun main(){
    val testSystem: ActorRef<String> = ActorSystem.create(SupervisingActor.create(), "first")
    testSystem.tell("failChild")
    testSystem.tell("stop")
}
```

監督された子アクターが再起動しているのがわかると思います
ちなみに```PreRestart```シグナルは再起動の前に処理されます。

```
子：起動するよ
子：今から例外で異状停止を再現するよ！
子：リスタート
子：起動するよ
子：停止
親:停止
```

<br>
<br>

## まとめ
Akka がどのようにアクターを階層的に管理し、親が子を監督して例外を処理するかについて学びました。
次にちょっと本格的なデバイスアクターシステムを作ってみましょう！


