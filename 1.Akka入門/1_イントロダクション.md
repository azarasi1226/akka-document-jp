# Akkaとは
Akkaはプロセッサ(cpu)・JVM・ネットワークをまたがったシステムを設計するためのオープンソースライブラリです。
Akkaで作成されたシステムは[リアクティブ宣言](https://www.reactivemanifesto.org/ja)に則った弾力的で耐障害性のあるシステム構成を低レベルなコードを描かなくても容易に達成することができ、コアドメイン(会社の主要な製品)の開発に集中することができます。

現在の多くの開発手法やプログラミングモデル(オブジェクト指向とか)は、複数台のコンピューターが同時に稼働するマイクロサービスのような最新のアーキテクチャと適合しておらず開発には相当な苦労が求められます。
例えば、マイクロサービスを構成する一つのコンピューターが破損したり、マイクロサービス間でのメッセージがいきなり紛失したりといった障害は、注意深く管理されたAWSなどのデータセンター内でも起こりうる可能性があるのです。

このような問題に対処するために、Akkaでは以下のような機能を開発者に提供してくれます。

* アトミックなロック(排他制御)などの低レベルな並行処理は非常に難しいですが、Akkaではこういった小難しい動作を気にしなくてもパフォーマンスの良い並列処理を提供してくれます。
* システム間のリモート通信(メッセージ)は難しいネットワークコードの記述と保守から開放し、位置透過性という特性でローカルでもクラスターでもまったく同じ手法でアクター間のメッセージ通信を実現します。
* AkkaClusterを利用した高可用性のあるアーキテクチャは弾力性と耐障害性を提供します。つまりマイクロサービスが作りやすくなります。

これらを実現するためにAkka内部ではアクターモデルというアーキテクチャを採用しています。
アクターモデルはAkkaが提供するライブラリの全てに使われているので、アクターモデルを理解するとライブラリの挙動を一貫して理解することが可能です。
Akkaではかく問題を解決するためのライブラリが多数用意されており、それを組み合わせることでリアクティブなシステムを構築することが可能になります。

<br>
<br>

# Akkaが求められる理由
アクターモデルは1973年に[カールヒューイット](https://en.wikipedia.org/wiki/Carl_Hewitt#Actor_model)により、未来では高性能なコンピューターによる高性能ネットワークでの並列処理ができるようになると予想し提案された方法です。
そして現在、ハードウェアとインフラの性能は向上しカールヒューイット氏が当時考えていたアクターモデルを実現することが可能となったのです。
その結果、従来のOOP(オブジェクト指向)では解決できなかった問題がアクターモデルの恩恵により解決できる可能性が生まれました。

<br>

## ムーアの法則の限界
1965年にCPUに搭載されるトランジスタは１年で２倍に増えていくとムーアさんが予測しました。
ところが1975年には２年で２倍になると下方修正し2000年になってからはほとんどCPU単体では性能アップが見込めなくなってしまったのです。そこで現在のCPUは多コア化により性能を向上させるという路線にシフトしており、ソフトウェア側もそれを意識したコーディングをしなければ高性能なアプリケーションが構築できなくなってしまいました。
しかし非同期、並列処理はちゃんと考えてやろうとするとすごく難しい...

<br>

## ユーザーの要求上がりすぎ問題
今までの巨大なアプリケーションは数秒の応答時間、数時間のメンテナンス(昔のネトゲは深夜メンテとかよくあったよね)が許容され、同時にやり取りされるにデータは数ギガ程度だった。
しかし、モバイル機器の爆発的な普及やGoogleやMicrosoftといった海外の圧倒的技術力を持った会社が作る高可用性で使いやすいアプリケーションに慣れ親しんだユーザーはミリ秒単位の応答時間、100％の可用性を求めるようになっていった。

現在広まっている主要なアーキテクチャやプログラミングのやり方ではこれらを達成するのが非常に困難になったのだ。

<br>

# アクターモデルを使うとなにが嬉しいのか
繰り返しになってくどいですが、一般的なプログラミング手法ではユーザーからの要求が過激な最新のシステムのニーズに対応することが難しいです。
アクターモデルを使うとどのように超規模アプリケーション構築時の問題を解決できるのかメジャーな利点２つを一緒に見ていきましょう！

<br>

## メッセージパッシングによりロックやブロッキングを回避できる
一般的なオブジェクト指向プログラミングではメソッドを呼び出しながらシステムを構築しますが、
アクターはお互いにメッセージを送信します。
一般的なメソッドでは呼び出し側のスレッドが処理が返ってくるまで停止した状態になります。
(C#のasync awaitとか非同期を意識した実装したら大丈夫だけど...)

しかしメッセージは送信したあとスレッドをブロックすることなく続行し、他の処理を受け持つことができます。
これにより、同じ時間でより多くの処理を達成することができるのです。

メッセージ送信とメソッド呼び出しの決定的な違いは戻り値が無いことです。
じゃぁどうやって結果返すんだよ...と思うと追われますが、戻り値をメッセージとして
送信することによってこの問題を解決します。
アクター間のやり取りはすべてノンブロッキングなメッセージによりやり取りされるのです。

また、アクターはメッセージを受け取るとアクター内で定義されたBehavior(振る舞い)で処理しますがその順序は１度に一つづつなので他のスレッドと競合すると言った問題が起こりません。C# のlcok構文やJavaのAtomicIntegerのようなロック機構を考えずにコーディングができます。
メッセージパッシングを利用すると脳死で非同期、並列処理への問題に対処できるようになるのです。

ロックが発生しないので数百万のアクターを数十のスレッドで効率的にスケジューリングすることが可能になり、現在のCPUの性能をフルに発揮することが可能になります。

<br>

## スーパーバイザによる障害の克服
メッセージパッシングではアクター間でコールスタック(例外のスタックトレースとかの情報)を共有しないので、呼び出し元でのtry-catchみたいな当たり前の芸当は使えません、どのようにアクター内で起こったエラーを処理するのでしょうか？
エラーにはおよそ２種類あり、それによって対処法が変わってきます。

### Error1 タスクのエラー
存在しないユーザーのIDでユーザーのを問い合わせしてしまったみたいな、想定されたエラーのことです。
この場合、送信元アクターにエラーケース(ユーザーが見つからん)を送信元に返信する必要があります。
エラーはドメインの知識の一部であり、通常のメッセージと同じ位置づけなのです。

> DDDだとドメイン例外とか使ってプレゼンテーション層で一律にキャッチとかするけどアクターモデルの場合は
想定されるエラー全ての返信を用意しなきゃいけない。普通にここらへんはめんどい

### Error2 内部的な障害
データベースに接続できなかったとか、アクターを管理するメモリが破損したーとかの想定されないエラーです。簡単に言うと例外です。

これはのち解説しますがアクターは階層構造を持っています。
子アクターで例外が発生し、子アクターが破損してしまった際は親アクターがその挙動を管理することができます。<br>
(再起動するとか、停止するとか..)
また、親アクターが一度停止すると子アクターも全て停止し、親アクターが再起動するものなら子アクターも一緒に再起動します。akkaではこれをスーパーバイザ戦略と呼び、Akkaの極めて重要な機能の一つと位置づけられています。

<br>

## 工凝集になりやすい
アクターは受け取るメッセージとそのメッセージに対する振る舞いを定義するので勝手に高凝集な設計になりやすいです。
一般的に良いシステムとは高凝集で低結合であるべきとされています。
ちなみにAkka公式はアクターモデルとはOOPの柱の一つであるカプセル化を極限まで追求したプログラミングスタイルみたいなことを言ってます。

<br>
<br>

# Akkaが提供するおもな機能一覧

## Actor
Akkaのコアライブラリです。Akka内ののライブラリのほぼ全てで使用されており一貫した結合モデルをakka全体で提供します。
並列処理や分散システムの設計で発生する頭を悩ませるような問題を解決し、OOPの制限から開放されたシステムの構築を手伝います。

* 高性能な並行アプリケーションを設計し構築ができる
* マルチスレッド環境でエラーを適切に処理できる
* 並行処理は難しすぎるのがアクターモデルを導入するとそれがましになる

<br>

## Remoting
異なるコンピューター(ネットワーク越し)にアクタがーメッセージを交換することを可能にします。
設定によって簡単に有効にすることができ、APIも僅かなものしか無いのですぐ使いこなせるようになると思います。

リモートとローカルのメッセージ送信方法はまったく同じであり、ActorRef参照が提供する位置透過性によりソーカルで適応していたパターンがそのままリモートでも適応できます。
後述のClusterの土台として組み込まれており、Remotingを直接使うといった機会はぶっちゃけ殆ど無いのでこういった物があるんだな程度に...

<br>

## Cluster
アクターを複数のノードと呼ばれる単位に分散し、一つのクラスを作成します。
更に具体的に言うとRemotnigがリモート間のコンポーネントやアドレスの問題を解決するものに対し、Clusterはこれらをメンバーシッププロトコルという特殊な通信で結びつけ一つの巨大なシステムとすることを提供します。

* クラスタのメンバー(ノード)の役割を指定する事ができ、特定のサービス(バックエンドとフロントエンド的な)に分割し管理することができる
* すでに存在するクラスターに安全にメンバーを追加できる。
* 一時的に到達不能(障害)が発生したメンバーを安全に切り離すことができる
* メンバーはお互いに相互通信が可能で、巨大なアクターシステムの集合とみなすことができる。

<br>

## Cluster Sharding
ShardingはAkkaクラスター上のメンバー上にアクターを分散させる問題を解決するのに役立ちます。
Shardingは主にPersistenceと一緒に使われることが多く、永続的なアクターの大きなセットを(シャードと呼ぶ)クラスタのメンバー上にバランスよく配置し、
メンバーがクラッシュしたり離脱した際にはそのシャードを他のメンバーに適切に振り分けることができます。

* クラスタ内のアクターが適切にう分散され、マシン間の負荷が適切に保たれる。
* クラッシュしたメンバーから、Persistenceを使うことにより状態を失うことなく復元ができる
* クラスター内に同じアクターが同時に存在しないように調節し、その結果不正義な値が生まれないようにしてくれる。

<br>

## Cluster Singleton
分散システムでよくあるユースケースで、ある機能を担当するエンティティをクラスタ内で一つだけ作り管理したいという場面があります。

* DNS的な一元的なネームサービス、またはルーティングサービス
* 特定のクラスタ全体で一貫した決定
* 外部システムへの単一のエントリポイント

ただ、設計で回避できるならこの機能は使わないほうが良いです。せっかくAkka Clusterで障害対策してるのにこのアクターが単一障害点になる可能性があるからです。ClusterSingleは本当に必要になったときに使うべきです。

<br>

## Persistence
当たり前ですがアクターの状態は揮発性であるメモリー上に保持されるのでシステムがシャットダウンもしくはクラッシュすると
メモリ内で保持していたアクタのデータは全て失われます。Persistenceはイベントソーシングを利用し状態をデータストアに保存することができるので好きなときにアクターを再構築することができるようになります。

イベントソーシングはアクターで発生したイベントを記録していく方式でそれを再生することで状態を復元します。
イベントストアへは追記しかしないのでトランザクションロック等が発生せず、アクターモデルの原則であるノンブロッキングを達成しています。
またCQRSなどを一緒に導入することで、マイクロサービスへの移行がしやすかったりといった利点もあります。

<br>

## DistributedData
最終的な一貫性(結果整合性って奴やな)が許容されるのであれば、クラスター間でのデータの共有にはDistributedDataが適しています。
これはCRDTという仕組みによりクラスタ内のアクターが書き込みと読み込みを同時に発生下としても、その後にいい感じにマージしてくれる機能です。あくまでも結果整合性なので各ノード内でアクセスした際に違ったデータが取得されることがあります!