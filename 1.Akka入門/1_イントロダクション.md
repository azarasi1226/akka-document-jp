# Akkaとは
Akkaはプロセッサ(cpu)・JVM・ネットワークをまたがったシステムを設計するためのオープンソースライブラリです。
Akkaで作成されたシステムは[リアクティブ宣言](https://www.reactivemanifesto.org/ja)に則った弾力的で耐障害性のあるシステム構成を低レベルなコードを描かなくても容易に達成することができ、コアドメイン(会社の主要な製品)の開発に集中することができます。

現在の多くの開発手法やプログラミングモデル(オブジェクト指向とか)は、複数台のコンピューターが同時に稼働するマイクロサービスのような最新のアーキテクチャと適合しておらず開発には相当な苦労が求められます。
例えば、マイクロサービスを構成する一つのコンピューターが破損したり、マイクロサービス間でのメッセージがいきなり紛失したりといった障害は、注意深く管理されたAWSなどのデータセンター内でも起こりうる可能性があるのです。

このような問題に対処するために、Akkaでは以下のような機能を開発者に提供してくれます。

* アトミックなロック(排他制御)などの低レベルな並行処理は非常に難しいですが、Akkaではこういった小難しい動作を気にしなくてもパフォーマンスの良い並列処理を提供してくれます。
* システム間のリモート通信(メッセージ)は難しいネットワークコードの記述と保守から開放し、位置透過性という特性でローカルでもクラスターでもまったく同じ手法でアクター間のメッセージ通信を実現します。
* AkkaClusterを利用した高可用性のあるアーキテクチャは弾力性と耐障害性を提供します。つまりマイクロサービスが作りやすくなります。

これらを実現するためにAkka内部ではアクターモデルというアーキテクチャを採用しています。
アクターモデルはAkkaが提供するライブラリの全てに使われているので、アクターモデルを理解するとライブラリの挙動を一貫して理解することが可能です。
Akkaではかく問題を解決するためのライブラリが多数用意されており、それを組み合わせることでリアクティブなシステムを構築することが可能になります。

<br>
<br>

# Akkaが求められる理由
アクターモデルは1973年に[カールヒューイット](https://en.wikipedia.org/wiki/Carl_Hewitt#Actor_model)により、未来では高性能なコンピューターによる高性能ネットワークでの並列処理ができるようになると予想し提案された方法です。
そして現在、ハードウェアとインフラの性能は向上しカールヒューイット氏が当時考えていたアクターモデルを実現することが可能となったのです。
その結果、従来のOOP(オブジェクト指向)では解決できなかった問題がアクターモデルの恩恵により解決できる可能性が生まれました。

<br>

## ムーアの法則の限界
1965年にCPUに搭載されるトランジスタは１年で２倍に増えていくとムーアさんが予測しました。
ところが1975年には２年で２倍になると下方修正し2000年になってからはほとんどCPU単体では性能アップが見込めなくなってしまったのです。そこで現在のCPUは多コア化により性能を向上させるという路線にシフトしており、ソフトウェア側もそれを意識したコーディングをしなければ高性能なアプリケーションが構築できなくなってしまいました。
しかし非同期、並列処理はちゃんと考えてやろうとするとすごく難しい...

<br>

## ユーザーの要求上がりすぎ問題
今までの巨大なアプリケーションは数秒の応答時間、数時間のメンテナンス(昔のネトゲは深夜メンテとかよくあったよね)が許容され、同時にやり取りされるにデータは数ギガ程度だった。
しかし、モバイル機器の爆発的な普及やGoogleやMicrosoftといった海外の圧倒的技術力を持った会社が作る高可用性で使いやすいアプリケーションに慣れ親しんだユーザーはミリ秒単位の応答時間、100％の可用性を求めるようになっていった。

現在広まっている主要なアーキテクチャやプログラミングのやり方ではこれらを達成するのが非常に困難になったのだ。

<br>

# アクターモデルを使うとなにが嬉しいのか
繰り返しになってくどいですが、一般的なプログラミング手法ではユーザーからの要求が過激な最新のシステムのニーズに対応することが難しいです。
アクターモデルを使うとどのように超規模アプリケーション構築時の問題を解決できるのかメジャーな利点２つを一緒に見ていきましょう！

<br>

## メッセージパッシングによりロックやブロッキングを回避できる
一般的なオブジェクト指向プログラミングではメソッドを呼び出しながらシステムを構築しますが、
アクターはお互いにメッセージを送信します。
一般的なメソッドでは呼び出し側のスレッドが処理が返ってくるまで停止した状態になります。
(C#のasync awaitとか非同期を意識した実装したら大丈夫だけど...)

しかしメッセージは送信したあとスレッドをブロックすることなく続行し、他の処理を受け持つことができます。
これにより、同じ時間でより多くの処理を達成することができるのです。

メッセージ送信とメソッド呼び出しの決定的な違いは戻り値が無いことです。
じゃぁどうやって結果返すんだよ...と思うと追われますが、戻り値をメッセージとして
送信することによってこの問題を解決します。
アクター間のやり取りはすべてノンブロッキングなメッセージによりやり取りされるのです。

また、アクターはメッセージを受け取るとアクター内で定義されたBehavior(振る舞い)で処理しますがその順序は１度に一つづつなので他のスレッドと競合すると言った問題が起こりません。C# のlcok構文やJavaのAtomicIntegerのようなロック機構を考えずにコーディングができます。
メッセージパッシングを利用すると脳死で非同期、並列処理への問題に対処できるようになるのです。

ロックが発生しないので数百万のアクターを数十のスレッドで効率的にスケジューリングすることが可能になり、現在のCPUの性能をフルに発揮することが可能になります。

<br>

## スーパーバイザによる障害の克服
メッセージパッシングではアクター間でコールスタック(例外のスタックトレースとかの情報)を共有しないので、呼び出し元でのtry-catchみたいな当たり前の芸当は使えません、どのようにアクター内で起こったエラーを処理するのでしょうか？
エラーにはおよそ２種類あり、それによって対処法が変わってきます。

### Error1 タスクのエラー
存在しないユーザーのIDでユーザーのを問い合わせしてしまったみたいな、想定されたエラーのことです。
この場合、送信元アクターにエラーケース(ユーザーが見つからん)を送信元に返信する必要があります。
エラーはドメインの知識の一部であり、通常のメッセージと同じ位置づけなのです。

> DDDだとドメイン例外とか使ってプレゼンテーション層で一律にキャッチとかするけどアクターモデルの場合は
想定されるエラー全ての返信を用意しなきゃいけない。普通にここらへんはめんどい

### Error2 内部的な障害
データベースに接続できなかったとか、アクターを管理するメモリが破損したーとかの想定されないエラーです。簡単に言うと例外です。

これはのち解説しますがアクターは階層構造を持っています。
子アクターで例外が発生し、子アクターが破損してしまった際は親アクターがその挙動を管理することができます。<br>
(再起動するとか、停止するとか..)
また、親アクターが一度停止すると子アクターも全て停止し、親アクターが再起動するものなら子アクターも一緒に再起動します。akkaではこれをスーパーバイザ戦略と呼び、Akkaの極めて重要な機能の一つと位置づけられています。