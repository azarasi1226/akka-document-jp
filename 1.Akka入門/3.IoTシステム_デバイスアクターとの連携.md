## イントロダクション
これまでのトピックでは、アクターシステムを大規模に見る方法、つまり、コンポーネントをどのように表現するか、アクターをどのように階層に配置するかについて説明しました。
このパートでは、デバイス・アクタを実装することで、アクタを小さな単位で見ていきます。

オブジェクトを扱う場合、通常、APIはインターフェースとして設計され、実際の実装によって補われる抽象的なメソッドの集合となります。
アクターの世界では、プロトコルがインターフェースの代わりを務めます。
一般的なプロトコルをプログラミング言語で公式化することはできませんが、その最も基本的な要素であるメッセージは構成することができます。
そこで、まずデバイスのアクターに送りたいメッセージを特定することから始めます。
> GRPCみたいやな...ちがうか...

一般的に、メッセージはカテゴリー、つまりパターンに分類されます。これらのパターンを識別することで、それらを選択し、実装することが容易になることが分かるでしょう。最初の例は、要求-応答メッセージのパターンを示しています。

<br>

## デバイス用メッセージの識別
デバイスアクターの仕事はシンプルなものになります。

* 温度測定の収集
* 求められたら、最後に測定した温度を報告すること

しかし、デバイスはすぐに温度測定ができない状態で起動することがあります。
したがって、温度が存在しない場合を考慮する必要があります。また、デバイスアクタが空の結果を報告することができるため、書き込み部分が存在しないアクタのクエリ部分をテストすることができる。

1. 現在の温度の要求を待つ。
2. リクエストに対して、以下のどちらかの返答をする。
   * には、現在の温度または
   * は、温度がまだないことを示しています。


```kotlin

import akka.actor.typed.ActorRef

class Device {
    sealed interface Command

    data class ReadTemperature(val replyTo: ActorRef<RespondTemperature>) : Command
    data class RespondTemperature(val value: Double?)
}

```

ReadTemperatureメッセージには、デバイスアクターがリクエストに応答するときに使用するActorRef<RespondTemperature>が含まれていることに注意してください。

この2つのメッセージは、必要な機能をカバーしているように見えます。しかし、私たちが選ぶアプローチは、アプリケーションの分散された性質を考慮に入れなければなりません。ローカルJVM上のアクターと通信するための基本的なメカニズムは、リモートアクターと通信する場合と同じですが、次のことを念頭に置いておく必要があります。

<br>

## メッセージの配信
メッセージング・サブシステムが提供する配信セマンティクスは、通常、次のカテゴリに分類されます。

* At-most-once delivery - 各メッセージは0回または1回だけ配信されます。より因果関係の深い用語では、メッセージが失われることはあっても、複製されることはないことを意味します。

* At-least-once delivery - 各メッセージを少なくとも1回成功させるまで、潜在的に複数の試行が行われる。

* Exactly-once delivery — 各メッセージは受信者に正確に一回だけ配信され、メッセージの紛失や複製は不可能です。

最初の動作は、Akka で使用されているもので、最も安価で、最も高いパフォーマンスをもたらします。送信側やトランスポートメカニズムで状態を保持することなく、fire and forget方式で実行できるため、実装のオーバーヘッドが最も少なくなります。2番目のat-least-onceは、トランスポートの損失に対抗するために再試行が必要である。これは、送信側で状態を保持し、受信側で確認応答メカニズムを持つというオーバーヘッドを追加するものである。at-least-once配信によって追加されるオーバーヘッドに加えて、重複する配信をフィルタリングするために、受信側で状態を保持する必要があります。

アクターシステムでは、どの時点でシステムが配送を達成したとみなすか、という保証の意味を正確に判断する必要があります。

1. ネットワーク上でメッセージを発信するとき？
2. メッセージがターゲットのアクターのホストで受信されたとき？
3. メッセージがターゲット・アクタのメールボックスに入れられたとき？
4. メッセージのターゲット・アクタがメッセージの処理を開始したとき？
5. ターゲット・アクタがメッセージの処理に成功したとき？

配信保証をうたうフレームワークやプロトコルの多くは、実際にはポイント4と5のようなものを提供しています。これは合理的に聞こえますが、実際に役に立つのでしょうか？その意味を理解するために、単純で実用的な例を考えてみましょう。ユーザーが注文をしようとして、それが実際に注文データベースのディスク上にあるときだけ、処理が成功したことを主張したいのです。

メッセージの処理の成功に依存する場合、アクターは、注文を検証し、処理し、データベースに格納する責任を負う内部 API に注文が送信されるとすぐに成功を報告します。残念ながら、APIが呼び出された直後には、以下のようなことが起こり得ます。

* ホストがクラッシュする可能性がある
* 非シリアライゼーションに失敗する可能性がある。
* バリデーションに失敗する可能性がある。
* データベースが利用できなくなる可能性がある。
* データベースが利用できなくなる可能性がある。

これは、配送の保証がドメインレベルの保証に結びつかないことを示しています。私たちは、注文が実際に完全に処理され、永続化されたときにのみ、成功を報告したいのです。成功を報告できるのは、アプリケーション自身だけです。なぜなら、アプリケーションだけが、必要なドメイン保証を理解しているからです。一般化されたフレームワークでは、特定のドメインの詳細と、そのドメインで何が成功とみなされるかを把握することはできない。

この例では、データベースへの書き込みが成功し、注文が安全に保存されたことをデータベースが認識した後にのみ、成功のシグナルを送りたいのです。このような理由から、Akka は保証の責任をアプリケーション自身に移譲しています。つまり、Akka が提供するツールを使って、あなた自身が保証を実装しなければなりません。では、アプリケーションロジックの推論を容易にするために、Akka が提供するメッセージの順序付けについて考えてみましょう。

* アクターA1はメッセージM1, M2, M3をA2に送信する。
* アクターA3はメッセージM4,M5,M6をA2に送る。

つまり...

* M1が納品されるなら、M2とM3より先に納品されなければならない。
* もしM2が納品されるなら、M3より前に納品されなければならない。
* もしM4が配達されるなら、それはM5とM6より前に配達されなければならない。
* もしM5が配送されたら、M6より先に配送されなければならない。
* A2はA1からのメッセージとA3からのメッセージをインターリーブして見ることができる。
* 配送は保証されていないので、どのメッセージも A2 に到着しない可能性がある。

あるアクターからのメッセージが順番に到着することは、容易に推論できるシステムを構築するのに便利であり、一方、異なるアクターからのメッセージが交互に到着することは、アクターシステムを効率的に実装するのに十分な自由度を提供する、これらの保証は良いバランスを保っている。


最初のクエリプロトコルは正しかったのですが、分散アプリケーションの実行を考慮していませんでした。デバイスアクタにクエリを送信するアクタで再送信を実装したい場合（リクエストがタイムアウトしたため）、または複数のアクタにクエリを送信したい場合、リクエストとレスポンスを関連付ける必要があります。したがって、メッセージにもう 1 つのフィールドを追加して、要求元から ID を提供できるようにします（このコードは、後のステップでアプリに追加します）。








https://akka-ja-2411-translated.netlify.app/general/message-delivery-reliability.html